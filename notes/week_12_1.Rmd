---
title: "Method of Steepest Ascent"
output:
  tufte::tufte_handout:
    citation_package: natbib
    latex_engine: xelatex
link-citations: yes
header-includes:
- \usepackage[fontsize=14pt]{scrextend}
---

Readings: 11.1 - 11.2

```{r, include=FALSE}
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

knitr::opts_chunk$set(message = FALSE, warning = FALSE, size = "small", echo = FALSE, fig.margin = TRUE, fig.height = 5, cache = TRUE)
```

```{r}
library("dplyr")
library("ggplot2")
library("readr")
library("EBImage")
library("reshape2")
library("tufte")
theme_set(theme_bw() + theme(legend.position = "bottom"))
```

When we last discussed response surfaces (in Chapter 5), we showed how to fit a
regression surface to a fixed set of runs. This let us find configurations of
factors that optimized some response of interest.

However, the real power of response surfaces emerges when we think sequentially,
using the results from one fit to plan a series of follow-up experiments, each
bringing us closer to an optimal configuration of factors.

## First and Second-Order Models

It makes sense to gradually refine our designs as we approach a potential
optimal point. At the start of experimentation, even a few small runs are likely
to point us in the right direction. Near the end, we’ll want to tune a good
configuration of factors into an optimal one.

One approach is to divide experimentation into two phases. We can start with
first-order models, and then proceed to second-order when in the vicinity of the
optimum.

* A first-order model is a linear model without any interactions or
nonlinearities. It can be fit using relatively few samples; for example,
unreplicated or fractional factorial designs. It is defined as,
\begin{align*}
y_{i} &= \beta_{0} + \sum_{k = 1}^{K}\beta_{k}x_{ik} + \epsilon_{i} \\
&= x_{i}^{T}b + \epsilon_{i}
\end{align*}

where we defined
\begin{align*}
x_{i} = \begin{pmatrix} 1 \\
x_{i1} \\
\vdots \\
x_{iK}
\end{pmatrix},
\end{align*}
and 
\begin{align*}
b = \begin{pmatrix}
\beta_0 \\
\beta_1 \\
\vdots \\
\beta_{K}
\end{pmatrix}
\end{align*}

* A second-order model is a linear model with interactions and quadratic terms.
These surfaces are more complex, so require more involved sampling, like
replicated factorial or central composite designs. It is defined as,
\begin{align*}
y_{i} &= \beta_0 + \sum_{k = 1}^{K}\beta_{kk}x_{k}^{2} + \sum_{k < k_{\prime}} \beta_{k k^{\prime}} x_{k}x_{k^{\prime}} + \epsilon_{i} \\
&= x{i}^{T}b + x_{i}^{T} B x_i + \epsilon_{i}
\end{align*}

where we defined $B$ as the symmetric $K \times K$ matrix with diagonal entries
$\beta_{kk}$ and off-diagonal elements $\frac{1}{2}\beta_{kl} =
\frac{1}{2}\beta_{lk}$.

## Method of Steepest Ascent

The method of steepest ascent uses the results of a first-order model to propose
a new configuration of factors that brings us closer to the optimum.
Specifically, we use the following recipe,

1. Using the current set of sampled factor configurations, fit the first-order
(linear) surface,
\begin{align*}
\hat{y}\left(x\right) &= x^{T}\hat{b}
\end{align*}

2. Find the coordinate $k^{\ast}$ of the coefficient that has the largest
magnitude,
\begin{align*}
	k^{\ast} &= \arg \max_{k \in \{1, \dots, K\}} \left|\hat{\beta}_{k}\right|
\end{align*}

which represents the factor to which the response is most sensitive. Define some
reasonable stepsize $\Delta x_{k^{\ast}}$ for this particular factor, so that
the next run brings us closer to the optimum without being so far that the
first-order model may not hold.

3. Update each factor’s sampling values according to the sensitivities
$\hat{\beta_{k}}$ of the response to that factor, and adjusting for the stepsize
defined in step (2).
	\begin{align*}
	x \leftarrow x + \frac{\Delta x_{k^{\ast}}}{\beta_{k^{\ast}}} b
	\end{align*}
	
## Code Example

Let’s apply this method to a real dataset. This example is in the vignette of
the `rsm` package.
